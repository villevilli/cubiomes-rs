//! Minecraft biome data generator
//!
//! This module is used to generate biomes from minecraft seeds
//! using the [Generator]
//!
//! # Usage
//!
//! For simple usage getting a biome at a specific place see [`Generator::get_biome_at()`]
//!
//! For more complicated usage, use a [Cache] generated with [`Cache::new()`]
//!
//! For structure generation, see [`crate::structures`]
//!
//! ## Optimal height
//!
//! For the y value in generation you should generally use minecraft build limit for surface biomes in the overworld.
//! (either 320 for post 1.18, or 255 for pre 1.18)
//! Note that this isn't exhaustive, please check the [minecraft wiki](https://minecraft.wiki/w/Altitude#History)
//! for an exhaustive list of changes in worldheight.
//!
//!
//!
//! # Details
//!
//! This module follow closely to how the underlying cubiomes library works, but the
//! features have been wrapped by a safe rust api

pub mod colors;
pub mod error;
mod range;

mod position;

#[cfg(test)]
mod tests;

use bitflags::bitflags;
use error::GeneratorError;
pub use position::*;
pub use range::*;

use std::{
    alloc::{alloc, dealloc, Layout},
    fmt::Debug,
    mem::transmute,
};

use crate::enums;
use cubiomes_sys::{getMinCacheSize, num_traits::FromPrimitive};

bitflags! {
    /// Flags for the cubiomes generator
    ///
    /// # Usage
    /// This indicates flags to pass to cubiomes. Unless you know what
    /// you are doing, you should probably leave these empty. Check the
    /// actual cubiomes library for documentation on what they do.
    pub struct GeneratorFlags: u32 {
        #[allow(missing_docs)]
        const LargeBiomes = 0x1;
        #[allow(missing_docs)]
        const NoBetaOcean = 0x2;
        #[allow(missing_docs)]
        const ForceOceanVariants = 0x4;
        //the source may set any bits
        #[allow(missing_docs)]
        const _ = !0;
    }
}

/// The cubiomes generator
///
/// This is the struct which holds a cubiomes generator
/// and is used for most actions with the generator
///
/// A new instance of the generator can be created with [`Generator::new()`]
///
/// Biomes can be generated either with [`Self::get_biome_at()`] for single points,
/// or in conjuntion with a [`Cache`] generated by [`Cache::new()`]
#[derive(Debug)]
pub struct Generator {
    generator: *mut cubiomes_sys::Generator,
}

impl Drop for Generator {
    fn drop(&mut self) {
        // Safety:
        // The memory is safe to deallocate as its been allocated in new
        // and the pointer to it is dropped, so it is never referred to again
        unsafe {
            dealloc(self.generator.cast::<u8>(), Layout::new::<Generator>());
        }
    }
}

// SAFETY: As the raw pointer inside generator is exclusive to this instance of
// generator, sending it in between threads should be safe. Only way to access
// the raw pointer is via unsafe.
unsafe impl Send for Generator {}

// SAFETY: The generator shouldn't have interior mutation without an exclusive
// mutable reference. All public api:s which mutate the internal generator
// (even briefly) should require an exclusive reference.
unsafe impl Sync for Generator {}

impl Generator {
    /// Initializes a new generator for the given minecraft version and flags
    /// with a seed and dimension applied
    ///
    /// This function initializes a new cubiomes generator and then gives
    /// it a seed.
    ///
    /// # Examples
    ///
    /// ```
    /// use cubiomes::generator::{Generator, GeneratorFlags};
    /// use cubiomes::enums::{MCVersion, Dimension};
    ///
    /// let seed: i64 = -4804349813814383506;
    /// let mc_version = MCVersion::MC_1_21_WD;
    ///
    /// let generator = Generator::new(mc_version, seed, Dimension::DIM_OVERWORLD, GeneratorFlags::empty());
    ///
    /// // Use the generator for something
    /// ```
    #[must_use]
    pub fn new(
        mc_version: enums::MCVersion,
        seed: i64,
        dimension: enums::Dimension,
        flags: GeneratorFlags,
    ) -> Self {
        // SAFETY:
        // the generator is immediatly given a seed
        unsafe {
            let mut generator = Generator::new_without_seed(mc_version, flags);
            generator.apply_seed(dimension, seed);

            generator
        }
    }

    /// Initializes a new generator for the given minecraft version and flags
    ///
    /// This function initializes a new cubiomes generator for the specified
    /// version of minecraft with the specified flags. To use the generator it
    /// must be given a seed with [`Self::apply_seed()`]
    ///
    /// # Safety
    /// Before using any generation functions one must use [`Self::apply_seed()`]
    /// to give the generator a seed, otherwise the generation will fail.
    ///
    /// # Examples
    /// ```
    ///    
    /// use cubiomes::generator::Generator;
    /// use cubiomes::enums::MCVersion;
    /// use cubiomes::generator::GeneratorFlags;
    ///
    /// // Version of minecraft to use with the generator
    /// let mc_version = MCVersion::MC_1_21_WD;
    /// let generator;
    /// unsafe{
    ///     generator = Generator::new_without_seed(mc_version, GeneratorFlags::empty());
    /// }
    /// ```
    #[must_use]
    pub unsafe fn new_without_seed(version: enums::MCVersion, flags: GeneratorFlags) -> Self {
        // SAFETY:
        // The function is safe since the generated pointer
        // points to memory that can fit a Generator and
        // the pointer is stored as a pointer
        unsafe {
            let generator =
                alloc(Layout::new::<cubiomes_sys::Generator>()).cast::<cubiomes_sys::Generator>();

            cubiomes_sys::setupGenerator(generator, version as i32, flags.bits());
            Self { generator }
        }
    }

    /// Sets the seed for the generator
    ///
    /// Sets a new seed to the generator. This can either be used for
    /// initialization if the generator was generated with [`Self::new_without_seed()`]
    /// or changing the seed of the generator
    pub fn apply_seed(&mut self, dimension: enums::Dimension, seed: i64) {
        // SAFETY:
        // As the generator is correctly initialized and its fields are private
        // the applySeed function is only given valid instances of generator
        unsafe {
            cubiomes_sys::applySeed(
                self.generator,
                dimension as i32,
                transmute::<i64, u64>(seed),
            );
        }
    }

    /// Tries to get a biomeid at the specific location.
    pub fn get_biome_at(&self, x: i32, y: i32, z: i32) -> Result<enums::BiomeID, GeneratorError> {
        // SAFETY:
        // As the generator is correctly initialized and its fields are private
        // the applySeed function is only given valid instances of generator.
        //
        // The scale enum guarantees that getBiomeAt is only given a scale of 1 or 4
        // As specified in its documentation
        unsafe {
            match cubiomes_sys::getBiomeAt(self.generator, Scale::Block as i32, x, y, z) {
                -1 => Err(GeneratorError::GetBiomeAtFailure),
                n => FromPrimitive::from_i32(n).ok_or(GeneratorError::BiomeIDOutOfRange(n)),
            }
        }
    }

    /// Gets the seed of [self]
    #[must_use]
    pub fn seed(&self) -> i64 {
        // SAFETY:
        // The generator pointer can't be null as its been initialized
        // when constructing this struct
        unsafe { transmute::<u64, i64>((*self.generator).seed) }
    }

    /// Gets the minecraft version of [self]
    #[must_use]
    pub fn minecraft_version(&self) -> enums::MCVersion {
        // SAFETY:
        // The generator pointer can't be null as its been initialized
        // when constructing this struct
        enums::MCVersion::from_i32(unsafe { *self.generator }.mc)
            .expect("Cubiomes generator has an invalid mc version")
    }

    /// Gets a raw mutable pointer to the underlying generator
    ///
    /// This can be used for calling into functions from `cubiomes_sys` with
    /// the raw pointer, or other activities invloving the raw cubiomes
    /// generator
    ///
    /// # Safety
    /// The pointer must remain pointing to a valid instance of the cubiomes generator
    ///
    /// The pointer shouldn't outlive the generator, as when dropped it gets unallocated
    ///
    /// Also keep in mind thread safety, if working in a multithreaded environment.
    pub unsafe fn as_mut_ptr(&mut self) -> *mut cubiomes_sys::Generator {
        self.generator
    }

    /// Gets a raw const pointer to the underlying generator
    ///
    /// This can be used for calling into `cubiomes_sys` with the raw pointer
    /// or other such things
    ///
    /// # Safety
    /// The data the pointer points to, should not be mutated. Use [`Self::as_mut_ptr()`]
    /// for mutating data.
    ///
    /// The pointer shouldn't outlive the generator, as when the generator is dropped
    /// the memory it points to becomes unallocated
    ///
    /// Also keep in mind thread safety. Do not mutate the type if you do not have
    /// exclusive access.
    #[must_use]
    pub unsafe fn as_ptr(&self) -> *const cubiomes_sys::Generator {
        self.generator
    }

    fn min_cache_size_from_range(&self, range: Range) -> usize {
        #[allow(clippy::unwrap_used)]
        let raw_range: cubiomes_sys::Range = range.try_into().unwrap();

        // SAFETY:
        // The conversion from cubiomes_sys::Range provides a range that fits the requirements
        // of the function
        unsafe {
            self.unchecked_min_cache_size(raw_range.scale, raw_range.sx, raw_range.sy, raw_range.sz)
        }
    }

    /// Gets the minimum cache size for a specific sized range
    ///
    /// y can be either 0 or 1 for a plane
    ///
    /// # Panics
    /// Panics if scale, `size_x`, or `size_z` are 0 or less and if `size_y` is less than 0
    unsafe fn unchecked_min_cache_size(
        &self,
        scale: i32,
        size_x: i32,
        size_y: i32,
        size_z: i32,
    ) -> usize {
        // SAFETY:
        // The unsafety is documented for the function.
        //
        // The requirement for this is checked from the source code and not from documentation
        unsafe { getMinCacheSize(self.generator, scale, size_x, size_y, size_z) }
    }

    /// Fills the provided cache from the generator
    ///
    /// # Safety
    /// The caller must guarantee, that the cache is able to contain the generated data.
    /// The best way to guarantee this, is to use a cache generated from this generator
    unsafe fn unchecked_generate_biomes_to_cache(
        &self,
        cache: &mut Cache,
    ) -> Result<(), GeneratorError> {
        let result_num = cubiomes_sys::genBiomes(
            self.generator,
            cache.buffer.as_mut_ptr(),
            cache.range.try_into()?,
        );

        // If error is returned from genbiomes, dont resize the vec as it may contain garbage data
        if result_num != 0 {
            return Err(GeneratorError::GenBiomeToCacheFailure(result_num));
        }

        // We set the caches lenght to what an user would want to read from it as we
        // can't be sure if cubiomes has actually initialized all variables beyond
        // the readable area.
        cache
            .buffer
            .set_len(cache.calculate_readable_cache_length());

        Ok(())
    }
}

/// A cache for generating and holding a chunk of biome data
///
/// The cache is usually generated with [`Self::new()`]
/// and holds a vector filled with biome data.
#[derive(Clone)]
pub struct Cache<'generator> {
    buffer: Vec<i32>,
    range: Range,
    generator: &'generator Generator,
}

//Custom dbg implementation, so we get the cache formatted as a table
impl Debug for Cache<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, ":")?;
        writeln!(f, "Range: {:?}", &self.range)?;
        writeln!(f, "Cache: ")?;

        for line in self.buffer.chunks(self.range.size_x as usize) {
            writeln!(f, "{line:?}")?;
        }
        Ok(())
    }
}

impl Cache<'_> {
    /// Generates a new cache for the given generator
    ///
    /// This function creates a new [`Cache`] against this version of the generator
    #[must_use]
    pub fn new(generator: &Generator, range: Range) -> Cache {
        let cache_size = generator.min_cache_size_from_range(range);
        let cache = Vec::with_capacity(cache_size);

        Cache {
            buffer: cache,
            range,
            generator,
        }
    }

    /// Fills the cache so it can be read
    pub fn fill_cache(&mut self) -> Result<(), GeneratorError> {
        // Safety:
        // As the cache holds a reference to the generator, the generator
        // could not have been modified after the vec was allocated so the
        // vec inside this cache holds enough space for the generator
        unsafe { self.generator.unchecked_generate_biomes_to_cache(self) }
    }

    /// Gets a reference to the internal representation of the cache.
    ///
    /// The cache is a linear array which can be accessed at the following
    /// index: ``y * self.range.sx * self.range.sz + z * self.range.sx + x``
    /// If the cache is a plane use y=0 for the index
    ///
    /// # Examples
    ///
    /// ```
    /// use cubiomes::generator::{Cache, Range, Scale};
    ///
    /// use cubiomes::generator::{Generator, GeneratorFlags};
    /// use cubiomes::enums::{MCVersion, Dimension, BiomeID};
    ///
    /// let mut generator = Generator::new(
    ///     MCVersion::MC_1_21_WD,
    ///     -380434930381432806,
    ///     Dimension::DIM_OVERWORLD,
    ///     GeneratorFlags::empty()
    /// );
    ///
    /// let mut cache = Cache::new(&generator, Range {
    ///     scale: Scale::Block,
    ///     x: 512,
    ///     z: -512,
    ///     size_x: 64,
    ///     size_z: 64,
    ///     y: 100,
    ///     size_y: 0,
    /// });
    ///
    /// cache.fill_cache().expect("failed to fill cache");
    ///
    /// // Read the cache at z=32, x=5
    ///
    /// assert_eq!(cache.as_vec()[(13 + cache.range().size_x + 5) as usize], BiomeID::plains as i32);
    ///
    #[inline]
    #[must_use]
    pub fn as_vec(&self) -> &Vec<i32> {
        &self.buffer
    }

    /// Gets a reference to the range used by this cache
    ///
    /// Gets the range this cache was generated with. Useful for
    /// if you want to read from the caches.
    ///
    /// See example from [`Self::as_vec()`] for example usage
    #[inline]
    #[must_use]
    pub fn range(&self) -> &Range {
        &self.range
    }

    /// This function gets a biome at the specified point in the cache
    ///
    /// The specified point is relative to the left upper corner of
    /// the caches range.
    ///
    /// The cache start from x:0 y:0 mapping to the 0,0 of the range it
    /// was generated with. This means that attempting to read x: 16 or y:16
    /// on a cache with a size of 16 will be out of bounds.
    pub fn biome_at(&self, x: u32, y: u32, z: u32) -> Result<enums::BiomeID, GeneratorError> {
        let raw_biomeid = *self
            .buffer
            .get((y * self.range.size_x * self.range.size_z + z * self.range.size_x + x) as usize)
            .ok_or(GeneratorError::IndexOutOfBounds)?;

        enums::BiomeID::from_i32(raw_biomeid).ok_or(GeneratorError::BiomeIDOutOfRange(raw_biomeid))
    }

    /// Moves the cache to new position x,y,z without reallocating the space
    ///
    /// Moves the cache to the new position without allocation.
    /// Can be used to generate multiple positions without reallocation.
    pub fn move_cache(&mut self, x: i32, y: i32, z: i32) {
        let new_range = Range {
            x,
            z,
            y,
            ..self.range
        };

        // As the size of the cache is only affeted by scale and size, moving the location won't
        // change the excpected cache size

        self.range = new_range;
    }

    /// Calculates the actual size of readable data within the cache
    fn calculate_readable_cache_length(&self) -> usize {
        let y_size = match self.range.size_y {
            0 => 1,
            n => n,
        };
        (self.range.size_x * self.range.size_z * y_size) as usize
    }
}
